**PROMPT (detailed, step-by-step specification — use this exactly to implement the project):**

Build a complete **Smart Voting System** web application using **HTML, CSS, JavaScript (webcam via `getUserMedia`)**, **Python Flask**, **PostgreSQL**, and **face_recognition (dlib / ResNet embeddings)**. Implement the project **step-by-step** below and produce a commit-ready repository with code, tests, migrations, and a README. Do not include any real secrets in the repo — use `.env` placeholders.

---

**High-level goals (must be satisfied):**

1. Real-time face authentication for voter verification (configurable threshold, default `0.6`).
2. Automated email alerts via Gmail SMTP (use app password) for:

   * Successful vote (confirmation email to the voter).
   * Authentication failure (alert email with captured photo, voter ID, timestamp to commissioner and the voter).
3. Secure, modular Flask app with admin (Election Commission) and polling (voter) flows.
4. Audit logging for all auth events and votes.
5. One vote per voter guaranteed by DB constraints and atomic transactions.

---

## Step-by-step implementation instructions

### Step 0 — Project skeleton & dependencies

* Create repository `smart_voting_system/`.
* Create `.env.example` with placeholders (see sample below).
* Create `requirements.txt` with at least:

  ```
  Flask
  Flask-Mail
  Flask-WTF
  Flask-Migrate
  Flask-SQLAlchemy
  python-dotenv
  psycopg2-binary
  face_recognition
  dlib
  opencv-python
  pillow
  numpy
  bcrypt
  flask-limiter
  reportlab
  pandas
  pytest
  ```
* Initialize Flask app factory pattern (app creation from `create_app(config_name)`).

---

### Step 1 — File structure (follow this layout)

```
smart_voting_system/
├─ app.py
├─ config.py
├─ .env.example
├─ requirements.txt
├─ README.md
├─ migrations/
├─ models/               # SQLAlchemy models
│  └─ __init__.py
├─ blueprints/
│  ├─ auth/              # admin + polling login
│  ├─ admin/             # voters/parties/candidates CRUD
│  ├─ poll/              # auth/verify/ballot/vote
│  └─ results/           # live results/export
├─ services/
│  ├─ face_service.py
│  ├─ email_service.py
│  ├─ audit_logger.py
│  └─ security.py
├─ templates/
├─ static/
│  ├─ js/
│  └─ css/
├─ uploads/
│  ├─ faces/
│  └─ fraud_attempts/
└─ tests/
```

---

### Step 2 — Environment & config

* Use `python-dotenv` to load `.env`.
* Required `.env` variables:

  ```
  SECRET_KEY=your_secret_key_here
  DB_URL=postgresql://user:password@localhost:5432/smart_voting
  EMAIL_USER=electioncomission101@gmail.com
  EMAIL_APP_PASSWORD=<GMAIL_APP_PASSWORD_PLACEHOLDER>
  EMAIL_FROM="Election Commission <electioncomission101@gmail.com>"
  ADMIN_DEFAULT_USER=admin
  ADMIN_DEFAULT_PASS_HASH=<bcrypt_hash_placeholder>
  FACE_MODEL=hog        # hog or cnn
  FACE_THRESHOLD=0.6
  ALERT_RECIPIENT=mithraa1906@gmail.com
  ```
* Add `.env` to `.gitignore`.

---

### Step 3 — Database schema & models (SQLAlchemy)

* Create models matching schema:

  * `Voter` (`id`, `voter_id` unique, `name`, `dob`, `age`, `gender`, `email` unique, `has_voted` boolean, `created_at`, `updated_at`)
  * `VoterFace` (`id`, `voter_id` FK, `encoding` JSON or BYTEA, `image_snapshot_path`, `created_at`)
  * `Party` (`id`, `name`, `symbol_path`, `created_at`)
  * `Candidate` (`id`, `party_id` FK, `name`, `image_path`, `created_at`)
  * `Vote` (`id`, `voter_id` FK unique, `candidate_id` nullable, `nota` boolean default false, `cast_at`, `audit_ref`)
  * `AuthEvent` (`id`, `voter_id` nullable FK, `voter_id_input`, `result` enum (success/mismatch/unknown), `distance` float, `snapshot_path`, `ip_address`, `user_agent`, `created_at`)
* Enforce DB constraint: `votes.voter_id` unique to disallow double voting.
* Use Flask-Migrate / Alembic for migrations.

---

### Step 4 — Blueprints & API endpoints (implement exactly)

* `auth` blueprint:

  * `POST /login` — admin/polling login (CSRF protected).
* `admin` blueprint:

  * `GET/POST/PUT/DELETE /admin/voters`
  * `POST /admin/voters/<id>/enroll-face` — accept webcam images, call face encoding logic, store encodings.
  * `GET/POST/PUT/DELETE /admin/parties`
  * `GET/POST/PUT/DELETE /admin/candidates`
  * `GET /admin/results/live` — JSON with per-candidate and per-party counts.
  * `GET /admin/results/export.csv`
  * `GET /admin/results/export.pdf`
  * `POST /admin/election/reset` — double confirm endpoint (admin only).
* `poll` blueprint:

  * `POST /poll/auth/start` — submit `voter_id` (init session), server returns if found and not voted.
  * `POST /poll/auth/verify` — receives one or more frames (or base64 image) and performs face verification; returns `{result: success|mismatch|unknown, distance: float}` and logs `AuthEvent`.
  * `GET /poll/ballot` — returns list of parties/candidates/NOTA for the ballot.
  * `POST /poll/vote` — record vote atomically; body includes `voter_id`, choice; returns success + `audit_ref`.
* `results` blueprint:

  * `GET /results/live` — SSE or pollable JSON endpoint.

---

### Step 5 — Face recognition service (`services/face_service.py`)

* Provide functions:

  * `enroll_images(voter_id, image_files:list) -> List[encodings]`:

    * For each image: detect face(s) with `face_recognition.face_locations(img, model=FACE_MODEL)`.
    * Compute `face_recognition.face_encodings(img, locations)` → 128-D vector.
    * Save encoding(s) (store as JSON list of 128 floats or BYTEA) and optionally snapshot image.
  * `verify_frame(voter_id, frame_image) -> (match:bool, distance:float, matched_known_encoding_id)`:

    * Load all known encodings for voter.
    * Detect face(s) in frame. If none, return `unknown`.
    * Compute encoding for detected face.
    * Compute Euclidean distances to stored encodings; take min distance.
    * If `min_distance < FACE_THRESHOLD` → `success`, else `mismatch`.
    * Return numeric `distance`.
* Use numpy for efficient distance calculation.
* Make `FACE_MODEL` and `FACE_THRESHOLD` configurable via `config`.

---

### Step 6 — Anti-spoofing & liveness

* Implement simple liveness:

  * When verifying, require two frames separated by ~1s and check small differences in landmark positions OR ask voter to blink / turn head.
  * Implement a "blink prompt" flow: show a prompt to the user to blink and verify blink detected by eye aspect ratio or frame difference.
  * Log `suspicion_score` in `AuthEvent` if liveness fails.

---

### Step 7 — Email service (`services/email_service.py`)

* Use `Flask-Mail` or `smtplib` securely with `.env`.
* Functions:

  * `send_vote_confirmation(voter_email, subject, body, reference_id)`:

    * Template subject: `"Your vote has been recorded"`.
    * Body: `Dear {Name}, your vote was recorded at {timestamp_local}. Choice: {Party/Candidate|NOTA}. Reference: {audit_ref}.`
  * `send_auth_failure_alert(recipients_list, subject, body, attachment_image_bytes)`:

    * Subject: `ALERT: Face authentication failure for Voter ID {VoterID}`
    * Body must include voter id used, timestamp (UTC and local), distance score, IP/User-Agent if available.
    * Attach the captured photo (appropriate MIME type).
* Ensure email sending is retryable and logged. Do NOT block request thread — send via background worker or separate thread (but for MVP a non-blocking thread is acceptable: `Thread(target=send).start()`).

---

### Step 8 — Frontend pages & interactions

* Landing/Login page:

  * Fullscreen voting background.
  * Two large buttons: `Election Commission` and `Polling System`. Clicking reveals appropriate login form.
* Admin pages: voters/parties/candidates CRUD with forms and file validation for images (MIME check + size max).
* Polling pages:

  * `auth.html`: prompt for `Voter ID` → start webcam via:

    ```js
    navigator.mediaDevices.getUserMedia({video: true})
    ```
  * Capture frames and POST base64 to `/poll/auth/verify`. Show red blinking + beep on `mismatch`.
  * On success redirect to `/poll/ballot`.
  * `ballot.html`: show parties (name + symbol) and candidates (name + image). Allow single choice or NOTA. Submit to `/poll/vote`.
  * `success.html`: show confirmation and reference id.
* UI behaviors:

  * Red blink CSS class + `<audio>` beep file for mismatch.
  * Inline validation and ARIA attributes for accessibility.
  * Use polling every 2–5s or Server-Sent Events (SSE) for live results in admin dashboard.

---

### Step 9 — Vote recording & transactional safety

* `POST /poll/vote` must:

  * Begin DB transaction.
  * Re-check `voter.has_voted` server side.
  * Insert `Vote` row with `audit_ref` (UUID or secure random string).
  * Set `voter.has_voted = True`.
  * Commit transaction; if commit fails due to unique constraint, rollback and return an error.
* Ensure atomicity using SQLAlchemy session transactions.

---

### Step 10 — Audit logging

* For each authentication attempt, create `AuthEvent` with:

  * `voter_id` if known else NULL
  * `voter_id_input` (string typed)
  * `result` (success|mismatch|unknown)
  * `distance` float
  * `snapshot_path` (file path of saved image)
  * `ip_address` and `user_agent`
  * `created_at` timestamp
* For each vote create a `Vote` record with `audit_ref` and create an `audit` log entry summarizing the event.

---

### Step 11 — Security hardening

* Hash admin passwords with `bcrypt`.
* Use `Flask-WTF` for CSRF tokens on forms.
* Use `Flask-Limiter` for rate limiting on auth endpoints (`/poll/auth/start`, `/poll/auth/verify`, `/login`).
* Validate & sanitize all file uploads: check actual MIME type (Pillow), and enforce max size (e.g., 2–5 MB).
* Serve cookies `HttpOnly` & `Secure` in production.
* Use HTTPS in production; configure Nginx + Certbot.

---

### Step 12 — Export & reporting

* Live results endpoint and admin dashboard must show:

  * Per candidate votes
  * Per party votes (sum of its candidates)
  * NOTA count
  * Winner calculation (admin policy: if tie, show tie and require manual admin resolution)
* Implement `export.csv` with headers: `party,candidate,count,nota,totals`.
* Implement `export.pdf` summary using `reportlab` or similar; include basic chart(s) if possible.

---

### Step 13 — Tests (automated)

* Unit tests and integration tests with `pytest`:

  * Test voter CRUD endpoints.
  * Test `verify_frame` function with sample images (mock face_recognition outputs if necessary).
  * Test `POST /poll/vote` for atomicity: simulate double vote attempt and assert unique constraint triggers.
  * Test email sending: use a mock SMTP or local test backend.
  * Test `AuthEvent` logging created with correct fields on success and mismatch.

---

### Step 14 — Acceptance criteria & manual test script

* Acceptance tests to run manually:

  1. Enroll a voter with 3 face images; confirm `VoterFace` entries created.
  2. Try to authenticate using correct person → should redirect to ballot; `AuthEvent.result=success`.
  3. Cast vote → `Vote` recorded, `voter.has_voted=True`, voter receives confirmation email.
  4. Try to authenticate with wrong person → `AuthEvent.result=mismatch`, red blink + beep, alert email with attached snapshot sent to commissioner and voter.
  5. Try to re-vote using same voter → blocked by DB constraint and API returns an error.
  6. Admin exports CSV and PDF and verifies content.
* Provide a short script/checklist in README with these manual steps.

---

### Step 15 — Logging & monitoring

* Log key events with timestamps to file and to DB (`AuthEvent`, `Vote`, `Login`).
* Keep rotating logs and limit disk usage for `uploads/fraud_attempts` and old snapshots.

---

### Step 16 — Deployment checklist

* Use `Gunicorn` to serve Flask and `Nginx` as reverse proxy.
* Use `systemd` to manage services.
* Use `Let's Encrypt` for TLS.
* Use environment variables for secrets in production (never commit `.env`).
* Back up DB regularly; restrict DB access to app server.

---

### Step 17 — README & documentation (deliver)

* Include `README.md` with:

  * Project overview and goals
  * Tech stack and architecture diagram (brief)
  * Installation and local dev setup (create venv, `pip install -r requirements.txt`, set `.env`, run migrations, run Flask)
  * How to generate and set Gmail app password
  * How to run tests
  * Acceptance test checklist
  * Security and privacy notes (face data handling)
* Provide API docs (brief) listing endpoints with request/response examples.

---

### Step 18 — Extra notes & constraints

* Default `FACE_MODEL=hog` for CPU-friendly operation; allow `cnn` if GPU available.
* Store face encodings as JSON arrays or `BYTEA`. If storing JSON, use PostgreSQL `jsonb`.
* Keep multiple encodings per voter for robustness (1–5 images).
* For email templates, include both UTC and local timestamps. Use `pytz` or `zoneinfo` to compute local times (user timezone from server config).
* Ensure uploaded images and snapshots are scanned for content and sanitized.

---

### Step 19 — Acceptance Criteria checklist (final verification)

* Voter authenticates only if face matches and valid Voter ID.
* On mismatch: red blink + beep + email alert with photo sent to commissioner and voter.
* On successful vote: record saved, voter locked, confirmation email sent.
* Admin can CRUD voters (with face enrollment), parties, candidates.
* Results show live counts; exports (CSV, PDF) work.
* All secrets in `.env`, admin passwords hashed, uploads validated, CSRF enabled, rate limiting enabled.

---

### Step 20 — Deliverable request to implementer / code generator

* Produce a ready repository implementing the above with:

  * Full code for each blueprint and service.
  * `migrations/` folder with initial migration.
  * `tests/` with unit & integration tests.
  * `README.md` and `.env.example`.
  * Minimal sample data fixture to create one admin user and two voters and one party/candidate for manual testing.
* **Do not** commit real secrets or app passwords. Use placeholders in `.env.example`.

---

**Email templates (exact wording to implement):**

* **Vote confirmation (subject):** `Your vote has been recorded`

  * **Body:**

    ```
    Dear {Name},

    Your vote was successfully recorded on {timestamp_local} (UTC: {timestamp_utc}).
    Choice: {Party/Candidate or NOTA}
    Reference ID: {audit_ref}

    Thank you,
    Election Commission
    ```

* **Auth failure alert (subject):** `ALERT: Face authentication failure for Voter ID {VoterID}`

  * **Body:**

    ```
    Alert:

    Voter ID used: {voter_id_input}
    Result: {mismatch | unknown}
    Distance: {distance if available}
    Time (local): {timestamp_local}
    Time (UTC): {timestamp_utc}
    IP: {ip_address}
    User-Agent: {user_agent}

    Attached: captured photo from the attempt.

    Please review the audit logs for more details.
    ```

---

**.env.example (final sample to include in repo):**

```
SECRET_KEY=REPLACE_ME
DB_URL=postgresql://username:password@localhost:5432/smart_voting
EMAIL_USER=electioncomission101@gmail.com
EMAIL_APP_PASSWORD=REPLACE_WITH_APP_PASSWORD
EMAIL_FROM="Election Commission <electioncomission101@gmail.com>"
ADMIN_DEFAULT_USER=admin
ADMIN_DEFAULT_PASS_HASH=REPLACE_WITH_BCRYPT_HASH
FACE_MODEL=hog
FACE_THRESHOLD=0.6
ALERT_RECIPIENT=mithraa1906@gmail.com
```

---

**End of prompt.** Implement exactly as specified above and ensure the acceptance checklist passes before marking the task done.
